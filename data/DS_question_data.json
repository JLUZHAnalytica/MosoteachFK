{
    "与单链表相比，双链表的优点之一是（ ）。": [
        "访问前后相邻节点更方便"
    ],
    "带头节点的双链表L为空表时应满足（ ）。": [
        "L->next==NULL",
        "L->next==NULL"
    ],
    "与非循环单链表相比，循环单链表的主要优点是（ ）。": [
        "从表中任意节点出发都能扫描到整个链表"
    ],
    "设有带头节点的循环单链表L，当这种链表成为空链表时，有（ ）。": [
        "表头节点的指针域next与L的值相等"
    ],
    "将两个分别含有m、n个节点的有序单链表归并成一个有序单链表，要求不破坏原有的单链表，对应算法的空间复杂度是（ ）（MIN表示取最小值）。": [
        "O(m+n)"
    ],
    "已知两个长度分别为m 和n 的升序单链表，若将它们合并为一个长度为m+n 的降序单链表，则最好情况下的时间复杂度是（ ）。": [
        "O(MIN(m,n))"
    ],
    "在长度为n（n≥1）的循环单链表L中，删除尾节点的时间复杂度为（ ）。": [
        "O(n)"
    ],
    "在只有尾节点指针rear没有头节点的非空循环单链表中，删除尾节点的时间复杂度为（ ）。": [
        "O(n)"
    ],
    "在只有尾节点指针rear没有头节点的非空循环单链表中，删除开始节点的时间复杂度为（ ）。": [
        "O(1)"
    ],
    "栈的“先进后出”特性是指（ ）。": [
        "最后进栈的元素总是最先出栈"
    ],
    "给定一个足够大的空栈，有4个元素的进栈次序为A、B、C、D，则以C、D开头的出栈序列的个数为（ ）。": [
        "1"
    ],
    "若元素a、b、c、d、e、f依次进栈，允许进栈、退栈的操作交替进行，但不允许连续3次退栈工作，则不可能得到的出栈序列是（ ）。": [
        "afedcb"
    ],
    "一个栈的进栈序列是a、b、c、d、e，则栈的不可能的输出序列是（ ）。": [
        "dceab"
    ],
    "当用一个数组data[0..n-1]存放栈中元素时，栈底最好（ ）。": [
        "设置在data[0]或data[n-1]处"
    ],
    "若一个栈用数组data[1..n]存储，初始栈顶指针top为n+1，则以下元素x进栈的正确操作是（ ）。": [
        "top--; data[top]=x;"
    ],
    "若一个栈用数组data[1..n]存储，初始栈顶指针top为0，则以下元素x进栈的正确操作是（ ）。": [
        "top++; data[top]=x;"
    ],
    "在设计链栈时，通常采用单链表作为链栈，而不采用双链表作为链栈，其准确的原因是（ ）。": [
        "栈中元素是顺序存取的，用单链表就足够了"
    ],
    "静态查找表和动态查找表的区别是（ ）。": [
        "施加其上的操作不同"
    ],
    "顺序查找法适合于存储结构为（ ）的线性表。": [
        "顺序存储或链式存储"
    ],
    "采用顺序查找方法查找长度为n的顺序表时，成功查找的平均查找长度为（ ）。": [
        "(n+1)/2"
    ],
    "采用顺序查找方法查找长度为n的顺序表时，不成功查找的平均查找长度为（ ）。": [
        "n"
    ],
    "适合于折半查找的数据组织方式是（ ）。": [
        "以顺序表存储的有序线性表"
    ],
    "采用折半查找方法查找长度为n的线性表，当n很大时，在等概率时不成功查找的平均查找长度为（ ）。": [
        "O(log2n)"
    ],
    "设有100个元素的有序表，采用折半查找方法，成功时最大的比较次数是（ ）。": [
        "7"
    ],
    "已知一个长度为16的顺序表，其元素按关键字有序排序，若采用折半查找法查找一个存在的元素，则比较的次数最多是（ ）。": [
        "5"
    ],
    "一个递增有序表为R[0..11]，采用折半查找方法进行查找，在一次不成功查找中，以下（ ）是不可能的记录比较序列。": [
        "R[5]、R[8]、R[10]"
    ],
    "对含有3600个记录的顺序表进行分块查找，并且采用顺序查找索引块，最理想的块长是（ ）。": [
        "60"
    ],
    "设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x进队的操作是（ ）;qu.data[qu.rear]=x。": [
        "qu.rear=(qu.rear+1)%N"
    ],
    "设循环队列qu中数组data的下标是0～N-1，其队头、队尾指针分别为f和r（f指向队首元素的前一位置，r指向队尾元素），元素x出队的操作是（ ）;x=qu.data[qu.front]。": [
        "qu.front=(qu.front+1)%N"
    ],
    "若某循环队列有队首指针front和队尾指针rear，在队不空时出队操作仅会改变（ ）。": [
        "front"
    ],
    "通常设置循环队列qu的队空条件（front队首指针指向队首元素的前一位置，rear队尾指针指向队尾元素）是（ ）。": [
        "qu.rear==qu.front"
    ],
    "设循环队列的存储空间为a[0..20]，且当前队头指针（f指向队首元素的前一位置）和队尾指针（r指向队尾元素）的值分别为8和3，则该队列中元素个数为（ ）。": [
        "16"
    ],
    "假设用一个不带头节点的单链表表示队列，队头在链表的（ ）位置。": [
        "链头"
    ],
    "与顺序队相比，链队（ ）。": [
        "缺点是不能根据队首和队尾指针计算队的长度"
    ],
    "若用一个大小为6的数组来实现循环队列，且当前rear和front的值分别为0和3，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（ ）。": [
        "2和4"
    ],
    "一个循环队列中用data[0..n-1]数组保存队中元素，另设置一个队尾指针rear和一个记录队中实际元素个数的变量count，则该队中最多可以存放的元素个数是（ ）。": [
        "n"
    ],
    "已知循环队列存储在一维数组A[0..n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。": [
        "0，n-1"
    ],
    "在循环队列中，元素的排列顺序（ ）。": [
        "由元素进队的先后顺序确定"
    ],
    "计算机所处理的数据一般具备某种内在联系，这是指（ ）。": [
        "元素和元素之间存在某种关系",
        "元素和元素之间存在某种关系"
    ],
    "在数据结构中，与所使用的计算机无关的是数据的（ ）结构。": [
        "逻辑",
        "逻辑"
    ],
    "在计算机中存储数据时，通常不仅要存储各数据元素的值，而且还要存储（ ）。": [
        "数据元素之间的关系"
    ],
    "数据结构在计算机内存中的表示是指（ ）。": [
        "数据的存储结构"
    ],
    "数据在计算机的存储器中表示时，逻辑上相邻的两个元素对应的物理地址也是相邻的，这种存储结构称之为（ ）。": [
        "顺序存储结构"
    ],
    "数据采用链式存储结构时，要求（ ）。": [
        "每个结点占用一片连续的存储区域"
    ],
    "可以用（ ）定义一个完整的数据结构。": [
        "抽象数据类型"
    ],
    "算法指的是（ ）。": [
        "求解特定问题的指令有限序列"
    ],
    "在算法设计时，若实参和形参同步发生改变，则应把形参变量说明为（ ）型参数。": [
        "引用"
    ],
    "某算法的时间复杂度为O(n2)，表明该算法的（ ）。": [
        "执行时间与n2成正比"
    ],
    "一个正确的递归算法通常包含（ ）。": [
        "递归出口和递归体"
    ],
    "递归函数f(x，y)定义如下：\n\nf(x，y)=f(x-1，y)+f(x，y-1)     当x>0且y>0\n\nf(x，y)=x+y                     否则\n\n则f(2，1)的值是（ ）。": [
        "4"
    ],
    "某递归算法的执行时间的递推关系如下：\n\nT(n)=1                        当n=1时\n\nT(n)=T(n/2)+1             当n>1时\n\n则该算法的时间复杂度为（ ）。": [
        "O(log2n)"
    ],
    "某递归算法的执行时间的递推关系如下：\n\nT(n)=1                         当n=1时\n\nT(n)=2T(n/2)+1            当n>1时\n\n则该算法的时间复杂度为（ ）。": [
        "O(n)"
    ],
    "将递归算法转换成非递归算法时，通常要借助的数据结构是（ ）。": [
        "栈"
    ],
    "以下关于二叉树的说法中正确的是（ ）。": [
        "二叉树中不存在度大于2的结点"
    ],
    "按照二叉树的定义，具有3个结点的二叉树有（ ）种。": [
        "5"
    ],
    "一棵完全二叉树中有1001个结点，其中度为1的结点个数是（ ）。": [
        "1"
    ],
    "一棵满二叉树有m个叶子结点和n个结点，其高度为h，则有（ ）。": [
        "n=2h-1"
    ],
    "设森林F中有4棵树，第1、2、3、4棵树的结点个数分别为a、b、c、d，则与森林F对应的二叉树根结点的左子树上的结点个数是（ ）。": [
        "a-1"
    ],
    "棵完全二叉树中有501个叶子结点，则至少有（ ）个结点。": [
        "1001"
    ],
    "设高度为h的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至少为()": [
        "2h-1"
    ],
    "以下关于排序的叙述中正确的是（ ）。": [
        "对同一个顺序表使用不同的排序方法进行排序，得到的排序结果可能不同"
    ],
    "对有n个记录的表进行直接插入排序，在最好情况下需比较（ ）次关键字。": [
        "n-1"
    ],
    "冒泡排序最少元素移动的次数是（ ）。": [
        "0"
    ],
    "采用排序算法对n个元素进行排序，其排序趟数肯定为n-1趟的排序方法是（ ）。": [
        "简单选择和直接插入",
        "简单选择和直接插入"
    ],
    "在一般情况下，以下排序算法中元素移动次数最少的（ ）。": [
        "简单选择排序",
        "简单选择排序"
    ],
    "二叉排序中，按（ ）遍历二叉排序得到的序列是一个有序序列。": [
        "中序"
    ],
    "在含有27个结点的二叉排序树上，查找关键字为35的结点，则依次比较的关键字有可能是（ ）。": [
        "46，36，18，28，35"
    ],
    "以下关于二叉排序树的叙述中正确的是（ ）。": [
        "在构造二叉排序树时，若关键字序列有序，则二叉排序树的高度最大"
    ],
    "有一棵含有8个结点的二叉排序树，其结点值为A～H，以下（ ）是其后序遍历结果。": [
        "BCAEFDHG"
    ],
    "具有5层结点的AVL树至少有（ ）个结点。": [
        "12"
    ],
    "以下关于哈希查找的叙述中错误的是（ ）。": [
        "用拉链法解决冲突易引起堆积现象"
    ],
    "以下关于哈希查找的叙述中正确的是（ ）。": [
        "哈希表的装填因子等于表中填入的记录数除以哈希表的长度"
    ],
    "为提高哈希（Hash）表的查找效率，可以采取的正确措施是（ ）。\nⅠ.增大装填（载）因子\nⅡ.设计冲突（碰撞）少的哈希函数\nⅢ.处理冲突（碰撞）时避免产生堆积（堆积）现象": [
        "仅Ⅱ、Ⅲ"
    ],
    "线性表是（ ）": [
        "一个有限序列，可以为空"
    ],
    "线性表的基本运算ListInsert(&L,i,e)表示在线性表L中第i个位置上插入一个元素e，若L的长度为n，则i的合法取值是（ ）。": [
        "1≤i≤n+1"
    ],
    "顺序表具有随机存取特性，指的是（ ）。": [
        "查找序号为i的元素与顺序表中元素个数n无关"
    ],
    "在顺序表中删除一个元素所需要的时间（ ）。": [
        "与删除元素的位置及顺序表的长度都有关"
    ],
    "在n（n>1）个运算的顺序表中，算法时间复杂度为O(1)的运算是（ ）。": [
        "访问第i个元素（2≤i≤n）并求其前驱元素"
    ],
    "关于线性表的顺序存储结构和链式存储结构的描述中，正确的是（ ）。\n\nⅠ.线性表的顺序存储结构优于链式存储结构\n\nⅡ.顺序存储结构比链式存储结构的存储密度高\n\nⅢ.如需要频繁插入和删除元素，最好采用顺序存储结构\n\nⅣ.如需要频繁插入和删除元素，最好采用链式存储结构": [
        "Ⅱ、Ⅳ"
    ],
    "在单链表中，增加一个头节点的目的是为了（ ）。": [
        "方便插入和删除运算的实现"
    ],
    "通过含有n（n≥1）个元素的数组a，采用头插法建立一个单链表L，则L中节点值的次序（ ）。": [
        "与数组a的元素次序相反"
    ],
    "某算法在含有n（n≥1）个节点的单链表中查找值为x节点，其时间复杂度是（ ）。": [
        "O(n)"
    ],
    "在长度为n（n≥1）的单链表中删除尾节点的时间复杂度为（ ）。": [
        "O(n)"
    ],
    "关于线性表的正确说法是（ ）。": [
        "除第一个元素和最后一个元素外，其余每个元素有且仅有一个前驱和一个后继元素"
    ],
    "以下关于顺序表的叙述中，正确的是（ ）。": [
        "顺序表和一维数组一样，都可以进行随机存取"
    ],
    "以下属于顺序表的优点是（ ）。": [
        "存储密度大"
    ],
    "设线性表中有n个元素，以下运算中，（ ）在单链表上实现要比在顺序表上实现效率更高。": [
        "删除指定位置元素的后一个元素"
    ],
    "以下关于单链表的叙述中正确的是（ ）。\n\nⅠ.节点除自身信息外还包括指针域，存储密度小于顺序表\n\nⅡ.找第i个节点的时间为O(1)\n\nⅢ.在插入、删除运算时不必移动节点": [
        "仅Ⅰ、Ⅲ"
    ],
    "树最适合用来表示（ ）。": [
        "元素之间具有分支层次关系的数据"
    ],
    "现有一“遗传”关系，设x是y的父亲，则x可以把他的属性遗传给y。表示该遗传关系最适合的数据结构为（ ）。": [
        "树"
    ],
    "一棵结点个数为n、高度为h的m（m≥3）次树中，其分支数是（ ）。": [
        "n-1"
    ],
    "若一棵度为7的树有7个度为2的结点，有6个度为3的结点，有5个度为4的结点，有4个度为5的结点，有3个度为6的结点，有2个度为7的结点，该树一共有（ ）个叶子结点。": [
        "78"
    ],
    "设树T的度为4，其中度为1、2、3、4的结点个数分别为4、2、1、1，则T中的叶子结点个数是（ ）。": [
        "8"
    ],
    "若一棵3次树中有2个度为3的节点，1个度为2的节点，2个度为1的节点，该树一共有（ ）个节点。": [
        "11"
    ],
    "有一棵三次树，其中n3=2，n2=1，n0=6，则该树的结点个数为": [
        "大于等于9的任意整数"
    ],
    "假设每个结点值为单个字符，而一棵树的后根遍历序列为ABCDEFGHIJ，则其根结点值是（ ）。": [
        "J"
    ],
    "一棵度为5、结点个数为n的树采用孩子链存储结构时，其中空指针域的个数是（ ）。": [
        "4n+1"
    ],
    "Dijkstra算法是（ ）方法求出图中从某点到其余顶点最短路径的。": [
        "按长度递增的顺序求出图的某顶点到其余顶点的最短路径"
    ],
    "用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻，S={0,2,3,4}，下一步选取的目标顶点可能是（ ）。": [
        "顶点7"
    ],
    "用Dijkstra算法求一个带权有向图G中从顶点0出发的最短路径，在算法执行的某时刻，S={0,2,3,4}，选取的目标顶点是顶点1，则可能修改最短路径是（ ）。": [
        "从顶点0到顶点1的最短路径"
    ],
    "对于n个顶点e条边的有向带权图，可以通过Dijkstra算法求出所有两个顶点之间的最短路径，此时的时间复杂度为（ ）。": [
        "O(n3)"
    ],
    "有一个顶点编号为0～4的带权有向图G，现用Floyd算法求任意两个顶点之间的最短路径，在算法执行的某时刻，已考虑了0～2的顶点，现考虑顶点3，则以下叙述中正确的是（ ）。": [
        "所有两个顶点之间的路径都可能被修改"
    ],
    "设有一个不带权的有向图G=（V，E），V={a,b,c,d,e}，E={<a,b>,<a,c>,<d,c>,<d,e>,<b,e>,<c,e>}，对该图进行拓扑排序，以下序列中不是拓扑序列的是（ ）。": [
        "abcde"
    ],
    "若一个有向图中的顶点不能排成一个拓扑序列，则可断定该有向图（ ）。": [
        "含有顶点数目大于1的强连通分量"
    ],
    "一颗二叉树的括号表示为“1(2(4,5(6,7)),3)”）。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列为3,1,7,5,6,2,4，则其遍历方式是（ ）。": [
        "RNL"
    ],
    "若二叉树（每个结点值为单个字符）的中序遍历序列是abcdef，且c为根结点，则（ ）。": [
        "结点c有两个孩子"
    ],
    "若知道该二叉树的（ ），便可以唯一确定该二叉树。": [
        "中序和后序序列"
    ],
    "一棵二叉树的先序遍历序列为ABCDEFG，它的中序遍历序列可能是（ ）。": [
        "ABCDEFG"
    ],
    "一棵二叉树的先序遍历序列为ABCDEF，中序遍历序列为CBAEDF，则后序遍历序列为（ ）。": [
        "CBEFDA"
    ],
    "某棵二叉树中，X结点有左孩子Y结点，则在其先序遍历中（ ）。": [
        "访问X结点后立即访问Y结点"
    ],
    "关于二叉树（含2个以上的结点）的先序遍历序列中，以下正确的是（ ）。": [
        "先序遍历序列的最后一个结点一定是叶子结点"
    ],
    "若一棵完全二叉树中每个结点值为单个字符，其后序遍历序列为CDBFGEA，则其先序遍历序列是（ ）。": [
        "ABCDEFG"
    ],
    "任何一棵二叉树的叶子结点在先序、中序和后序遍历序列中的相对次序（ ）。": [
        "相同"
    ],
    "若二叉树采用二叉链存储结构，要删除该二叉链中所有结点并释放它们占用的空间，利用（ ）遍历方法最合适。": [
        "后序"
    ],
    "判断线索二叉树中p结点为叶子结点的条件是（ ）。": [
        "p->ltag==1且p->rtag==1"
    ],
    "一个无向连通图的生成树是含有该连通图的全部顶点的（ ）。": [
        "极小连通子图"
    ],
    "任何一个带权无向连通图（ ）最小生成树。": [
        "有一棵或多棵"
    ],
    "用Prim算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的顶点集合U＝{1,2,3}，已选取的边的集合TE＝{(1,2)，(2,3)}，要选取下一条权值最小的边，应当从（ ）组中选取。": [
        "{(1,4)，(3,4)，(3,5)，(2,5)}"
    ],
    "对某个带权连通图构造最小生成树，以下说法中正确的是（ ）。\nⅠ.该图的所有最小生成树的总代价一定是唯一的\nⅡ.其所有权值最小的边一定会出现在所有的最小生成树中\nⅢ.用普里姆（Prim）算法从不同顶点开始构造的所有最小生成树一定相同\nⅣ.使用普里姆算法和克鲁斯卡尔（Kruskal）算法得到的最小生成树总不相同": [
        "仅Ⅰ"
    ],
    "用Kruskal算法求一个连通的带权图的最小代价生成树，在算法执行的某时刻，已选取的边集合TE＝{(1,2)，(2,3)，(3,5)}，要选取下一条权值最小的边，不可能选取的边是（ ）。": [
        "(1,3)"
    ],
    "在用Prim和Kruskal算法构造最小生成树时，前者更适合于（  ）": [
        "稠密图"
    ],
    "在用Prim和Kruskal算法构造最小生成树时，后者更适合于（  ）": [
        "稀疏图"
    ],
    "下面关于串的叙述中，正确的是（ ）。": [
        "串是一种特殊的线性表"
    ],
    "两个字符串相等的条件是（ ）。": [
        "两个串的长度相等且对应位置的字符相同"
    ],
    "若串str=“Software”，其子串的个数是（ ）。": [
        "37"
    ],
    "一个链串的节点类型定义为\n\n\n#define NodeSize  6\n\ntypedef struct node\n\n{   char data[NodeSize];\n\n    struct node *next;\n\n} LinkStrNode;\n\n如果每个字符占1个字节，指针占2个字节，该链串的存储密度为（ ）。": [
        "3/4"
    ],
    "串采用节点大小为1的链表作为其存储结构，是指（ ）。": [
        "链表中每个节点的数据域中只存放一个字符"
    ],
    "对于一个链串s，查找第一个字符值为x的算法的时间复杂度为（ ）。": [
        "O(n)"
    ],
    "设有两个串p和q，其中q是p的子串，则求q在p中首次出现位置的算法称为（ ）。": [
        "模式匹配"
    ],
    "在串的简单模式匹配中，当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。": [
        "i=i-j+1"
    ],
    "在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则i的位移方式是（ ）。": [
        "i不变"
    ],
    "在KMP模式匹配中，用next数组存放模式串的部分匹配信息。当模式串位j与目标串位i比较时，两字符不相等，则j的位移方式是（ ）。": [
        "j=next[j]"
    ],
    "n个节点的线索二叉树上含有的线索个数为（ ）。": [
        "n+1"
    ],
    "设有一棵哈夫曼树的结点总数为35，则该哈夫曼树共有（ ）个叶子结点。": [
        "18"
    ],
    "根据使用频率为5个字符设计的哈夫曼编码不可能是（ ）。": [
        "100,11,10,1,0"
    ],
    "下面关于哈夫曼树的说法，错误的是（ ）。": [
        "哈夫曼树中除了度为1的结点外，还有度为2的结点和叶子结点"
    ],
    "以下不属于内排序方法的是（ ）。": [
        "拓扑排序"
    ],
    "目前来讲，基于比较的内排序方法最好的平均时间复杂度为（ ）。": [
        "O(nlog2n)"
    ],
    "数据序列{8，9，10，4，5，6，20，1，2}只能是（ ）算法的两趟排序后的结果。": [
        "直接插入排序"
    ],
    "对数据序列{15，9，7，8，20，-1，4}进行排序，进行一趟后数据的排序变为{4，9，-1，8，20，7，15}，则采用的是（ ）算法。": [
        "希尔排序"
    ],
    "以下排序方法中，（ ）在初始序列已基本有序的情况下，排序效率最高。": [
        "直接插入排序"
    ],
    "已知用某种排序方法对关键字序列{51，35，93，24，13，68，56，42，77}进行排序时，前两趟排序的结果为\n（35，51，24，13，68，56，42，77，93）\n（35，24，13，51，56，42，68，77，93）\n所采用的排序方法是（ ）。": [
        "冒泡排序"
    ],
    "对一组数据(25，84，21，47，15，27，68，35，20)进行排序，前3趟的排序结果如下：\n第1趟：20，15，21，25，47，27，68，35，84\n第2趟：15，20，21，25，35，27，47，68，84\n第3趟：15，20，21，25，27，35，47，68，84\n则所采用的排序方法是（ ）。": [
        "快速排序"
    ],
    "有n个十进制整数进行基数排序，其中最大的整数为5位，则基数排序过程中临时建立的队数个数是（ ）。": [
        "10"
    ],
    "为实现快速排序法，待排序序列宜采用存储方式是（ ）。": [
        "顺序存储"
    ],
    "快速排序在（ ）情况下最不利于发挥其长处。": [
        "排序的数据已基本有序"
    ],
    "以下序列不是堆的是（ ）。": [
        "{100，85，40，77，80，60，66，98，82，10，20}"
    ],
    "对含有n个元素的数据序列采用堆排序方法，其中调用筛选算法有（ ）次。": [
        "(3n-2)/2"
    ],
    "已知序列{18，12，16，10，5，15，2，8，7}是大根堆，删除一个元素后再调整为大根堆，调整后的大根堆是（ ）。": [
        "{16，12，15，10，5，7，2，8}"
    ],
    "对n个元素采用二路归并排序，其中归并的趟数是（ ）。": [
        "élog2nù"
    ],
    "数据序列{10，9，8，7，6，5，4，3，2，1}采用二路归并排序方法进行递增排序，第2趟排序结束后的结果是（ ）。": [
        "{7，8，9，10，3，4，5，6，1，2}"
    ],
    "在长度为n（n≥1）的双链表中插入一个节点（非尾节点）要修改（ ）个指针域。": [
        "4"
    ],
    "对于长度为n（n≥1）的双链表L，在p所指节点之前插入一个新节点的算法的时间复杂度为（ ）。": [
        "O(1)"
    ],
    "在长度为n（n≥1）的双链表中删除一个节点（非尾节点）要修改（ ）个指针域。": [
        "2"
    ],
    "在长度为n（n≥1）的循环双单链表L中，删除尾节点的时间复杂度为（ ）。": [
        "O(1)"
    ],
    "在长度为n（n≥1）的双链表L中，删除p所指节点的时间复杂度为（ ）。": [
        "O(1)"
    ],
    "两个长度为n的双链表，节点类型相同，若以h1为头指针的双链表是非循环的，以h2为头指针指针的双链表是循环的，则（ ）。": [
        "对于循环双链表来说，删除尾节点的操作，其时间复杂度都是O(1)"
    ],
    "在一个具有n个顶点的无向连通图中至少有（ ）条边。": [
        "n-1"
    ],
    "设G是一个含有6个顶点的无向图，该图至多有（ ）条边。": [
        "15"
    ],
    "在一个具有n个顶点的有向图中，构成强连通图时至少有（ ）条边。": [
        "n"
    ],
    "以下关于有向图的说法中，正确的是（ ）。": [
        "完全有向图一定是强连通图"
    ],
    "非空无向图的邻接矩阵是一个（ ）。": [
        "对称矩阵"
    ],
    "一个图的邻接矩阵是对称矩阵，则该图是（ ）。": [
        "无向图或有向图"
    ],
    "在含有n个顶点e条边的不带权无向图的邻接矩阵中，零元素的个数为（ ）。": [
        "n2-2e"
    ],
    "若用邻接矩阵表示一个含有n个顶点不带权的有向图，则其中第i（0≤i≤n-1）列中包含的1的个数为（ ）。": [
        "图中顶点i的入度"
    ],
    "一个图的邻接表表示中有奇数个边结点，则该图是（ ）。": [
        "有向图"
    ],
    "以下叙述中错误的是（ ）。": [
        "图的深度优先遍历不适合有向图"
    ],
    "如果从无向图的任一顶点出发进行一次广度优先遍历即可访问所有顶点，则该图一定是（ ）。": [
        "连通图"
    ],
    "对有n个顶点、e条边且使用邻接表存储的有向图进行深度优先遍历，其算法的时间复杂度是（ ）。": [
        "O(n+e)"
    ],
    "对有n个顶点、e条边且使用邻接矩阵存储的有向图进行广度优先遍历，其算法的时间复杂度是（ ）。": [
        "O(n2)"
    ],
    "一个有向图G=(V，E)，V={0，1，2，3，4}，E={<0，1>，<1，2>，<0，3>，<1，2>，<1，4>，<2，4>，<4，3>}，现按深度优先遍历算法遍历，从顶点0出发，所得到的顶点序列是（ ）。": [
        "0，1，2，4，3"
    ],
    "以下关于广度优先遍历的叙述中正确的是（ ）。": [
        "对一个强连通图调用一次广度优先遍历算法便可访问所有的顶点"
    ],
    "有一个三维数组A[-2..2][-4..5][2..6]，其中元素个数是（ ）。": [
        "250"
    ],
    "设C/C++二维数组a[m][n]，每个数组元素占用k个存储单元，第一个数组元素的存储地址是LOC(a[0][0])，求按行优先顺序存放的数组元素a[i][j]（0≤i≤m-1，0≤j≤n-1）的存储地址为（ ）。": [
        "LOC(a[0][0])+[i×n+j]×k"
    ],
    "设二维数组a[1..5][1..8]，若按行优先的顺序存放数组的元素，则a[4][6]元素的前面有（ ）个元素。": [
        "29"
    ],
    "设C/C++二维数组a[6][10]，每个数组元素占用4个存储单元，若按行优先顺序存放所有数组元素，a[3][5]的存储地址为1000，则a[0][0]的存储地址是（ ）。": [
        "860"
    ],
    "一个n阶对称矩阵A采用压缩存储方式，将其下三角部分（含主对角线元素）按行优先存储到一维数组B中，则B中元素个数是（ ）。": [
        "n(n+1)/2"
    ],
    "一个n阶对称矩阵A[1..n，1..n]采用压缩存储方式，将其下三角部分按行优先存储到一维数组B[1..m]中，则A[i][j]（i<j）元素在B中的位置k是（ ）。": [
        "j(j-1)/2+i"
    ],
    "一个n阶上三角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。": [
        "n(n+1)/2+1"
    ],
    "一个n(n>3)阶三对角矩阵A按行优先顺序压缩存放在一维数组B，则B中元素个数是（ ）。": [
        "3n-2"
    ],
    "稀疏矩阵常用的压缩存储方法有（ ）。": [
        "三元组和十字链表"
    ],
    "稀疏矩阵采用压缩存储后的缺点之一是（ ）。": [
        "丧失随机存取特性"
    ]
}